# Array (static)

## 배열의 특성

1. 고정된 저장 공간
2. 순차적인 데이터 저장

배열은 선언시에 크기를 정하여 해당 크기만큼의 연송된 메모리를 할당 받아 데이터를 연속적/순차적으로 저장하는 자료구조

```c
// C lang
int arr[5] = {1, 2, 3 ,4 ,5};
int* ptr = array;
*(ptr + 1) // arr[1]의 값과 같다.
// c언어에서는 arr이라는 변수에 arr의 첫번째 요소의 주소값이 저장되어 있다.(포인터와는 다르게 동작)
```

```java
// JAVA
int[] arr = {1, 2, 3, 4, 5};
```

```js
// JS
// 정적 배열 개념이 없음
const arr = [1, 2, 3, 4, 5];
```

```python
# pytnon
# 정적 배열 개념이 없음
arr = [1, 2, 3, 4, 5]
```

## 배열의 요소 접근 (Random Access)

배열은 메모리 주소 기반으로 데이터에 접근하기 때문에 O(1)의 시간복잡도로 데이터에 접근할 수 있다.

## 배열의 요소 검색

배열의 요소 검색에는 O(N)의 시간복잡도가 소요 된다. 배열의 전체 요소를 순회하면서 찾고자 하는 값이 있는지 확인해야 하기 때문이다. 이와 같은 검색을 선형 검색이라고 한다.

## 배열의 요소 삽입

배열의 요소 삽입은 요소를 배열의 어느 위치에 삽입하냐에 따라서 시간 복잡도가 달라진다. 배열의 가장 끝에 요소를 삽입한다면 하나의 단계가 필요하다. (언어마다 차이점이 있음. js의 push(), python의 append()가 가능하지만, 정적 배열을 사용하는 언어에서는 size(length)를 초과한 인덱스에 값을 추가할 수 없음)

배열의 중간에 값 하나를 추가하려는 경우에는 추가하고자 하는 index의 요소부터 마지막 index 요소까지 한 칸씩의 이동이 필요하다. 삽입 시 최악의 시나리오는 가장 앞에 값을 추가할 때이고, 최고의 시나리오는 가장 뒤에 배열의 값을 추가하는 것이다.

## 배열의 요소 삭제

요소 삭제 역시 삽입과 비슷하다. 중간의 요소를 삭제하면 삭제한 요소 뒤의 요소들을 모두 하나씩 인덱스를 옮겨야 하므로 최악의 경우 O(N)의 시간 복잡도를 가진다.

## static arary의 한계

static array는 데이터의 크기가 정해져 있을 때는 효율적이다. 하지만 선언시에 정한 크기보다 더 많은 데이터를 저장해야 하는 경우 배열의 할당된 메모리 크기를 넘어서기 때문에 문제가 발생할 수 있다. 그렇다고 매번 엄청 큰 배열을 선언하면 메모리 비효율이 발생한다.

### Reference

- 누구나 자료구조와 알고리즘(도서)
- 코딩테스트 [ALL IN ONE] (인프런 강의)
